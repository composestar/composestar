package Composestar.DotNET.TYM.SignatureTransformer;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import Composestar.Core.Exception.ModuleException;
import Composestar.Core.Master.CTCommonModule;
import Composestar.Core.Master.CommonResources;
import Composestar.Core.TYM.TypeLocations;
import Composestar.Utils.FileUtils;

/**
 * This class will modify references to the dummies dll so that 
 * the types from the 'real' dlls are used.
 * 
 * No longer used.
 * 
 * @author Staijen
 */
public class DummyUnlinker implements CTCommonModule
{
	private TypeLocations typeLocations;

	public DummyUnlinker()
	{
		typeLocations = TypeLocations.instance();
	}

	public void run(CommonResources resources) throws ModuleException
	{
		MSAssembler assembler = new MSAssembler();		
		List assemblies = (List)resources.getResource("BuiltAssemblies");
		Set assemblyNames = typeLocations.assemblies();
		Set typeNames = typeLocations.typeNames();

		Iterator asmIt = assemblies.iterator();
		while (asmIt.hasNext())
		{
			String asmpath = FileUtils.unquote((String)asmIt.next());
			String asmname = FileUtils.getFilenamePart(asmpath);
			String ilpath = asmpath + ".il";

			try {
				assembler.disassemble(asmpath, ilpath);
				String[] ilCode = readLines(ilpath);

				String newCode = unlinkDummies(ilCode, asmname, assemblyNames, typeNames);
				writeFile(ilpath, newCode);
				
				assembler.assemble(ilpath, asmpath);
			}
			catch (Exception e) {
				throw new ModuleException("Dummy Unlinking failure in " + asmpath + ", reason: " + e.getMessage());
			}
		}
	}
	
	/**
	 * @param ilCode
	 * @param selfName
	 * @param assemblyNames
	 * @return java.lang.String
	 * @roseuid 40FD27B201A3
	 */
	private String unlinkDummies(String[] ilCode, String selfName, Set assemblyNames, Set typeNames)
	{
		StringBuffer sb = new StringBuffer();
		sb.append("// Generated by Compose* DummyUnlinker\r\n");

		for (int i = 0; i < ilCode.length; i++)
		{
			String line = ilCode[i];
			if (line.trim().startsWith(".assembly extern dummies"))
			{
				sb.append(createExternDeclarations(selfName, assemblyNames));
				i += 3; // TODO: use dropSection
			}
			else
				sb.append(line).append("\r\n");
		}
		
		String result = sb.toString();

		// TODO: describe what this is supposed to do (extract method?)
		if (result.indexOf("[dummies]") != -1) 
		{
			Iterator it = typeNames.iterator();
			while (it.hasNext())
			{
				String typeName = (String)it.next();
				String assembly = typeLocations.getAssemblyByType(typeName);
				result = result.replaceAll("\\[dummies\\]" + typeName, "\\[" + assembly + "\\]" + typeName);

				if (result.indexOf("[dummies]") == -1)
					break;
			}
		}

		return result;     
	}

	private String createExternDeclarations(String selfName, Set externSet)
	{
		StringBuffer sb = new StringBuffer();
		Iterator esIt = externSet.iterator();
		while (esIt.hasNext())
		{
			String name = (String)esIt.next();
			if (! name.equals(selfName))
			{
				sb.append(".assembly extern ").append(name).append("\r\n");
				sb.append("{\r\n");
				sb.append("\t.ver 0:0:0:0\r\n");
				sb.append("}\r\n");
			}
		}
		return sb.toString();
	}

	/**
	 * TODO: move to FileUtils?
	 */
	private String[] readLines(String path) throws IOException
	{
		List lines = new ArrayList();
		BufferedReader reader = null;
		try {
			reader = new BufferedReader(new FileReader(path));

			String line = reader.readLine();
			do {
				lines.add(line);
				line = reader.readLine();
			}
			while (line != null);
		}
		finally {
			FileUtils.close(reader);
		}

		return (String[])lines.toArray(new String[lines.size()]);     
	}

	/**
	 * TODO: move to FileUtils?
	 */
	private void writeFile(String path, String content) throws Exception
	{
		FileWriter writer = null;
		try {
			writer = new FileWriter(path);
			writer.write(content);
		}
		finally {
			FileUtils.close(writer);
		}
	}
}
