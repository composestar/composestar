package Composestar.DotNET.TYM.SignatureTransformer;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import Composestar.Core.Exception.ModuleException;
import Composestar.Core.Master.CTCommonModule;
import Composestar.Core.Master.CommonResources;
import Composestar.Core.TYM.TypeLocations;

/**
 * This class will modify references to the dummies dll so that 
 * the types from the 'real' dlls are used.
 * 
 * @author Staijen
 */
public class DummyUnlinker implements CTCommonModule
{
	private TypeLocations typeLocations;

	public DummyUnlinker()
	{
		typeLocations = TypeLocations.instance();
	}

	public void run(CommonResources resources) throws ModuleException
	{
		MSAssembler assembler = new MSAssembler();		
		List assemblies = (List)resources.getResource("BuiltAssemblies");
		HashSet assemblyNames = typeLocations.assemblies();
	//	String[] types = reverseBubbleSort(typeLocations.types());
		List typeNames = typeLocations.typeNames();

		Iterator asmIt = assemblies.iterator();
		while (asmIt.hasNext())
		{
			String asm = (String)asmIt.next();
			String asmpath = asm.replaceAll("\"", "");
			String ilpath = asmpath + ".il";
			String asmname = asmpath.substring(asmpath.lastIndexOf("/") + 1);

			try {
				assembler.disassemble(asmpath, ilpath);
				String[] ilCode = readLines(ilpath);

				HashSet externSet = (HashSet)assemblyNames.clone();
				externSet.remove(asmname);

				String newCode = unlinkDummies(ilCode, asmname, externSet, typeNames);
				writeFile(ilpath, newCode);
				assembler.assemble(ilpath, asmpath);
			}
			catch (Exception e) {
				throw new ModuleException("Dummy Unlinking failure in " + asmpath + ", reason: " + e.getMessage());
			}
		}     
	}

//	/**
//	 * @param names
//	 * @return java.lang.String[]
//	 * @roseuid 40FD27B20194
//	 */
//	private String[] reverseBubbleSort(String[] names)
//	{
//		for (int i = names.length -1; i >= 0; i--)
//		{
//			for (int j = 0; j < i; j++)
//			{
//				if (names[j].compareTo(names[j+1]) < 0 )
//				{
//					String temp = names[j];
//					names[j] = names[j + 1];
//					names[j + 1] = temp;
//				}
//			}
//		}
//
//		return names;     
//	}

	/**
	 * @param ilCode
	 * @param selfName
	 * @param externSet
	 * @return java.lang.String
	 * @roseuid 40FD27B201A3
	 */
	private String unlinkDummies(String[] ilCode, String selfName, Set externSet, List typeNames)
	{
		StringBuffer sb = new StringBuffer();
		sb.append("// Generated by Compose* DummyUnlinker");

		for (int i = 0; i < ilCode.length; i++)
		{
			String line = ilCode[i];
			if (line.trim().startsWith(".assembly extern dummies"))
			{
				sb.append(createExternDeclarations(externSet));
				i += 3; // TODO: use dropSection
			}
			else
				sb.append(line).append("\r\n");
		}
		
		String result = sb.toString();

		// TODO: describe what this does (extract method?)
		if (result.indexOf("[dummies]") != -1) 
		{
			Iterator it = typeNames.iterator();
			while (it.hasNext())
			{
				String typeName = (String)it.next();
				String assembly = typeLocations.getAssemblyByType(typeName);
				result = result.replaceAll("\\[dummies\\]" + typeName, "\\[" + assembly + "\\]" + typeName);

				if (result.indexOf("[dummies]") == -1)
					break;
			}
		}

		return result;     
	}

	/**
	 * @param externSet
	 * @return java.lang.String
	 * @roseuid 40FD27B201C2
	 */
	public String createExternDeclarations(Set externSet)
	{
		StringBuilder sb = new StringBuilder();
		Iterator esIt = externSet.iterator();
		while (esIt.hasNext())
		{
			String name = (String)esIt.next();
			sb.append(".assembly extern ").append(name).append("\r\n");
			sb.append("{\r\n");
			sb.append("\t.ver 0:0:0:0\r\n");
			sb.append("}\r\n"); 
		}
		return sb.toString();
	}

	/**
	 * @param path
	 * @return java.lang.String[]
	 * @throws Exception
	 * @roseuid 40FD27B201D2
	 */
	public String[] readLines(String path) throws Exception {
		ArrayList lines = new ArrayList();

		BufferedReader reader = new BufferedReader(new FileReader(path));

		String line = reader.readLine();
		do
		{
			lines.add(line);
			line = reader.readLine();
		}
		while( line != null );

		reader.close();

		return (String[])lines.toArray(new String[lines.size()]);     
	}

	/**
	 * @param path
	 * @param content
	 * @throws Exception
	 * @roseuid 40FD27B2028D
	 */
	public void writeFile(String path, String content) throws Exception {
		FileWriter w = new FileWriter(path);
		w.write(content);
		w.close();     
	}
}
