package Rot13Filter;

import java.lang.Thread;
import Composestar.RuntimeCore.FLIRT.Actions.*;
import Composestar.RuntimeCore.FLIRT.Message.*;
import Composestar.RuntimeCore.FLIRT.Reflection.*;
import Composestar.RuntimeCore.Utils.*;

/**
 * Binds the filter with an ACT to do the actual rotation.
 * Based upon Runtime\FLIRT\actions\MetaAction.java.
 */
public class RotAction extends ComposeStarAction 
{
	ReifiedMessage message;

	/**
	 * Constructs a Meta action. For this is needed a reified version of the
	 * message, an ACT with a method in it, and wheather or not the message was
	 * accepted.
	 *
	 * @param  rm           Reified version of the message.
	 * @param  act          ACT to handle the reified message.
	 * @param  actSelector  Name of the method that handles the reified message.
	 * @param  accepted     If the message was accepted or not.
	 */
	public RotAction(MessageList m, ReifiedMessage rm, Object act, String actSelector, boolean accepted) 
	{
		super(m, accepted);

		this.message = rm;

		Object[] args = new Object[1];
		args[0] = rm;
		act = new RotACT(13);
		this.message.setActMethodInfo(act, "Rotate", args);

		this.continueMessage = m;
	}
    
	/**
	 * Execute the filter by calling the associated ACT (Rot13ACT).
	 */
	public Object execute()
	{
		// Start execution in a new thread
		Thread t = new Thread(this.message);
		t.start();

		// Store jp and m in ACT thread.
		JoinPoint __jp = JoinPointInfo.getJoinPointInfo();
		JoinPointInfoProxy.updateJoinPoint(t,__jp);
		Message __m = MessageInfo.getMessageInfo();
		MessageInfoProxy.updateMessage(t,__m);

		t.start();

		// Block until ACT calls send(), reply() or fire() on the reified message.
		this.message.getContinueBuffer().consume();

		// Update message after execution.
		this.continueMessage.copyFromMessageList( message.getMessageListCopy() );

		this.shouldContinue = this.message.shouldContinue();

		return this.message.getReturnValue();     
	}

	public MessageList getMessageToContinueWith()
	{
		return this.continueMessage;
	}
}
